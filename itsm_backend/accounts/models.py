"""
Accounts App Models

Imports Phase 2 model definitions for User, Role, and UserRole.
These models represent:
- User: System user with authentication credentials (extends AbstractBaseUser)
- Role: Predefined system roles (USER, EMPLOYEE, MANAGER, ADMIN)
- UserRole: User role assignments with optional department/team scope
"""
import uuid
import bcrypt
from django.db import models
from django.contrib.auth.models import AbstractBaseUser, BaseUserManager, PermissionsMixin
from django.core.validators import MinValueValidator, MaxValueValidator
from django.utils import timezone


# =============================================================================
# ABSTRACT BASE MODELS
# =============================================================================

class BaseModel(models.Model):
    """
    Abstract base with UUID primary key.
    
    NOTE: Primary key is generated by Django using uuid.uuid4().
    """
    id = models.UUIDField(
        primary_key=True,
        default=uuid.uuid4,
        editable=False,
        db_column='id'
    )

    class Meta:
        abstract = True


class TimestampedModel(BaseModel):
    """Abstract base with timestamps."""
    created_at = models.DateTimeField(auto_now_add=True, db_index=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        abstract = True


# =============================================================================
# CUSTOM USER MANAGER
# =============================================================================

class UserManager(BaseUserManager):
    """
    Custom user manager for the ITSM User model.
    
    Handles user creation with bcrypt password hashing for compatibility
    with existing password hashes.
    """
    
    def create_user(self, email, name, alias, password=None, **extra_fields):
        """
        Create and save a regular user.
        
        Args:
            email: User's email address (required)
            name: User's full name (required)
            alias: User's alias/username (required)
            password: Plain text password (optional)
            **extra_fields: Additional fields for the User model
            
        Returns:
            User instance
        """
        if not email:
            raise ValueError('Users must have an email address')
        if not name:
            raise ValueError('Users must have a name')
        if not alias:
            raise ValueError('Users must have an alias')
        
        email = self.normalize_email(email)
        extra_fields.setdefault('is_active', True)
        extra_fields.setdefault('is_staff', False)
        extra_fields.setdefault('is_superuser', False)
        
        user = self.model(
            email=email,
            name=name,
            alias=alias,
            **extra_fields
        )
        
        if password:
            user.set_password(password)
        
        user.save(using=self._db)
        return user
    
    def create_superuser(self, email, name, alias, password=None, **extra_fields):
        """
        Create and save a superuser.
        
        Args:
            email: User's email address (required)
            name: User's full name (required)
            alias: User's alias/username (required)
            password: Plain text password (required for superuser)
            **extra_fields: Additional fields for the User model
            
        Returns:
            User instance with superuser privileges
        """
        extra_fields.setdefault('is_staff', True)
        extra_fields.setdefault('is_superuser', True)
        extra_fields.setdefault('is_active', True)
        
        if extra_fields.get('is_staff') is not True:
            raise ValueError('Superuser must have is_staff=True.')
        if extra_fields.get('is_superuser') is not True:
            raise ValueError('Superuser must have is_superuser=True.')
        
        return self.create_user(email, name, alias, password, **extra_fields)


# =============================================================================
# ORGANIZATION HIERARCHY
# =============================================================================

class BusinessGroup(BaseModel):
    """Top-level organizational unit."""
    name = models.CharField(max_length=255, unique=True)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = 'BusinessGroup'
        ordering = ['name']

    def __str__(self):
        return self.name


class Company(BaseModel):
    """Company within a business group."""
    business_group = models.ForeignKey(
        BusinessGroup,
        on_delete=models.PROTECT,
        related_name='companies'
    )
    name = models.CharField(max_length=255)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = 'Company'
        ordering = ['name']
        verbose_name_plural = 'Companies'

    def __str__(self):
        return self.name


class Department(BaseModel):
    """Department within a company."""
    company = models.ForeignKey(
        Company,
        on_delete=models.PROTECT,
        related_name='departments'
    )
    name = models.CharField(max_length=255)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = 'Department'
        ordering = ['name']

    def __str__(self):
        return f"{self.company.name} - {self.name}"


class Team(BaseModel):
    """Team within a department, managed by a manager."""
    department = models.ForeignKey(
        Department,
        on_delete=models.PROTECT,
        related_name='teams'
    )
    name = models.CharField(max_length=255)
    manager = models.ForeignKey(
        'User',
        on_delete=models.PROTECT,
        related_name='managed_teams',
        null=True,
        blank=True
    )
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = 'Team'
        ordering = ['name']

    def __str__(self):
        return f"{self.department.name} - {self.name}"


# =============================================================================
# USER & ACCESS CONTROL
# =============================================================================

class User(AbstractBaseUser, PermissionsMixin, TimestampedModel):
    """
    System user with authentication credentials.
    
    Extends Django's AbstractBaseUser for full Django integration including:
    - Django Admin support
    - Permission system integration
    - Bcrypt password hashing (via custom set_password)
    
    Also extends TimestampedModel for UUID primary key and timestamps.
    """
    alias = models.CharField(max_length=100, unique=True)
    name = models.CharField(max_length=255)
    email = models.EmailField(max_length=255, unique=True)
    phone = models.CharField(max_length=50, null=True, blank=True)
    
    # Django auth fields
    password = models.CharField(max_length=255, db_column='password_hash')
    is_active = models.BooleanField(default=True)
    is_staff = models.BooleanField(
        default=False,
        help_text='Designates whether the user can access the admin site.'
    )
    # Note: is_superuser is provided by PermissionsMixin
    
    last_login = models.DateTimeField(null=True, blank=True)

    # Custom manager
    objects = UserManager()
    
    # Required for Django auth
    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = ['name', 'alias']
    
    def set_password(self, raw_password):
        """
        Hash password using bcrypt for compatibility with existing hashes.
        
        Args:
            raw_password: Plain text password to hash
        """
        if raw_password:
            password_bytes = raw_password.encode('utf-8')
            salt = bcrypt.gensalt(rounds=12)
            self.password = bcrypt.hashpw(password_bytes, salt).decode('utf-8')
        else:
            self.set_unusable_password()
    
    def check_password(self, raw_password):
        """
        Verify password using bcrypt.
        
        Args:
            raw_password: Plain text password to verify
            
        Returns:
            True if password matches, False otherwise
        """
        if not self.password or not raw_password:
            return False
        try:
            password_bytes = raw_password.encode('utf-8')
            hash_bytes = self.password.encode('utf-8')
            return bcrypt.checkpw(password_bytes, hash_bytes)
        except Exception:
            return False

    class Meta:
        db_table = 'User'
        ordering = ['name']
        indexes = [
            models.Index(fields=['email'], name='IX_User_Email'),
            models.Index(fields=['alias'], name='IX_User_Alias'),
            models.Index(fields=['is_active'], name='IX_User_Active'),
        ]

    def __str__(self):
        return f"{self.name} ({self.alias})"


class Role(models.Model):
    """
    Predefined system roles.
    Seeded values: USER, EMPLOYEE, MANAGER, ADMIN
    """
    id = models.IntegerField(primary_key=True)
    name = models.CharField(max_length=50, unique=True)

    # Role constants for application layer
    USER = 1
    EMPLOYEE = 2
    MANAGER = 3
    ADMIN = 4

    class Meta:
        db_table = 'Role'
        ordering = ['id']

    def __str__(self):
        return self.name


class UserRole(BaseModel):
    """
    User role assignments with optional department/team scope.
    Supports multi-role per user.
    """
    user = models.ForeignKey(
        User,
        on_delete=models.CASCADE,
        related_name='user_roles'
    )
    role = models.ForeignKey(
        Role,
        on_delete=models.PROTECT,
        related_name='user_roles'
    )
    department = models.ForeignKey(
        Department,
        on_delete=models.PROTECT,
        related_name='user_roles',
        null=True,
        blank=True
    )
    team = models.ForeignKey(
        Team,
        on_delete=models.PROTECT,
        related_name='user_roles',
        null=True,
        blank=True
    )

    class Meta:
        db_table = 'UserRole'
        indexes = [
            models.Index(fields=['user', 'role'], name='IX_UserRole_UserRole'),
            models.Index(fields=['team', 'user'], name='IX_UserRole_Team'),
            models.Index(fields=['department', 'user'], name='IX_UserRole_Dept'),
        ]
        constraints = [
            models.UniqueConstraint(
                fields=['user', 'role', 'department', 'team'],
                name='UQ_UserRole_Unique'
            )
        ]

    def __str__(self):
        return f"{self.user.name} - {self.role.name}"
